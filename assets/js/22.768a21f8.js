(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{343:function(e,n,t){"use strict";t.r(n);var a=t(25),s=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"vue源码实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue源码实现"}},[e._v("#")]),e._v(" Vue源码实现")]),e._v(" "),n("p",[e._v("npm install pnpm -g")]),e._v(" "),n("p",[e._v("pnpm init")]),e._v(" "),n("p",[e._v("当 shamefully-hoist 设置为 true 时，pnpm 会尝试模仿传统的 npm 和 yarn 行为，将所有依赖项都安装在项目的根 node_modules 文件夹中，而不是将它们分散到各个子文件夹中。 这通常是为了解决某些与路径解析或特定工具集成相关的问题。 然而，需要注意的是，使用 shamefully-hoist 可能会失去 pnpm 的主要优势之一，即节省磁盘空间。")]),e._v(" "),n("p",[e._v("pnpm install vue@3.4.0 -w\n-w根目录")]),e._v(" "),n("p",[e._v("minimist 解析命令行参数")]),e._v(" "),n("p",[e._v("pnpm install typescript esbuild minimist -D -w")]),e._v(" "),n("p",[e._v("配制workspace （pnpm-workspace.yaml）\npackages:")]),e._v(" "),n("ul",[n("li",[e._v('"packages/*"')])]),e._v(" "),n("p",[e._v("pnpm tsc --init 或者npx tsc --init 找到node_modules的.bin下的tsc")]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v('{\n  "compilerOptions": {\n    "outDir": "dist",//输出的目录\n    "sourceMap": true,//采用sourcemap\n    "target": "es2016",//目标语法\n    "module": "esnext",//模块格式\n    "moduleResolution": "node",//模块解析方式\n    "strict": false,//严格模式\n    "resolveJsonModule": true,//解析json模块\n    "esModuleInterop": true,//允许通过es6语法引入commonjs模块\n    "jsx": "preserve",//jsx 不转义\n    "lib": ["esnext", "dom"] //支持的类库 esnext及dom\n  }\n}\n')])])]),n("p",[e._v('不能在node环境使用esModule语法\npackage.json 添加 type: "module"')]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v('//以这个文件为基准，定义包的路径\n"baseUrl": ".",\n"paths": {\n  "@vue/'),n("span",{pre:!0,attrs:{class:"token italic"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("*")]),n("span",{pre:!0,attrs:{class:"token content"}},[e._v('": ["packages/')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("*")])]),e._v('/src"]\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("加workspace不让它以为第三方的包\npnpm install @vue/shared --workspace --filter @vue/reactivity\n")])])]),n("p",[e._v("reactivity :\n不能被重复代用，已经代理过了\neg: 重复代用\nconst obj = {name:'durant', age: 35}\nconst state1 = reactive(obj);\nconst state2 = reactive(obj);\neg: 已经代理过了。需要重新理解\nconst song = {song:'进阶'};\nconst state1 = reactive(song);\nconst state2 = reactive(state1);")]),e._v(" "),n("p",[e._v("Proxy, Reflect（调取对象的基本方法，receiver改变this指向）")]),e._v(" "),n("p",[e._v("核心代码：effect类， 用于依赖收集，触发（页面）更新")]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v("effect(函数，选项)\neffect的函数本身调用一遍。effect是一个类。\n{\n  active: \n  fn: effect中的函数\n  scheduler: \n}\n\nhtml:\nactiveEffect: 当前执行上下文的effect。\neffect(() => {\n  app.innerHTML = "),n("span",{pre:!0,attrs:{class:"token code-snippet code keyword"}},[e._v("`姓名${state.name}`")]),e._v(";\n  effect(() => {\n    state.name = 'durant123'\n    app.innerHTML = "),n("span",{pre:!0,attrs:{class:"token code-snippet code keyword"}},[e._v("`姓名${state.name}`")]),e._v(";\n  })\n})\n")])])]),n("p",[e._v("关键代码，依赖收集（让响应式属性和effect映射起来）")]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v("track: 一个大的WeackMap ，内含Map,又含Map\nMap : {obj : {属性： Map: {effect, effect} } } \n\neffect自身调用，发现state.name/state.age, 进行依赖收集，\neffect(() => {\n  app.innerHTML = "),n("span",{pre:!0,attrs:{class:"token code-snippet code keyword"}},[e._v("`姓名${state.name} 年龄${state.age}`")]),e._v(";\n})\n\n// effect，才会被数据收集，trigger发现被收集了，触发更新。（数据变化了，触发更新/调用trigger）\nsetTimeout(() => {\n  state.age = 999;\n})\n")])])]),n("p",[e._v("effect的延伸：不同条件依赖不同（重新收集依赖）,存在相同依赖， 依赖减少了")]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v("// {obj: { flag: {effect}, {name: {effect} } }\n// {obj: { flag: {effect}, {age: {effect} } }\n\neffect(() => {\n  app.innerHTML = state.flag ? state.name + state.name: state.age;\n})\nsetTimeout(() => {\n  state.flag = false;\n  setTimeout(() => {\n    state.name = 'james';//这里需要effect\n  }, 1000)\n}, 1000)\n\n// {flag,name}\n// {flag,age}\n简易diff算法\n\n_trackId 用于记录执行次数，防止一个属性在当前effect中多次依赖收集\n\n// {flag,name,age,year}\n// {flag}\n")])])]),n("p",[e._v("effect的选项options")]),e._v(" "),n("p",[e._v("scheduler调用run,想晚点调用run(AOP编程/面向切面编程，在原有的逻辑，增加自己的逻辑)")]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v('let runner = effect(\n  () => {\n    app.innerHTML = state.flag ? state.name : state.age;\n  },\n  {\n    scheduler: () => {\n      console.log("数据更新了，不直接渲染，走一下自己的逻辑先");\n      runner(); //重新渲染\n    }\n  }\n)\n')])])]),n("p",[e._v("effect的优化：防止递归，深度代理")]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v("//防止递归\neffect(() => {\n  app.innerHTML = state.name;\n  state.name = Math.random();//更新了数据，不要再执行effect了。effect加个_running正在执行的逻辑\n})\n//深度代理\neffect(() => {\n  state.info.address = '北京天安门';\n})\n")])])]),n("p",[e._v("ref")]),e._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[e._v("const flag = ref(false); //wrap,包了一层，因为对象在访问属性的时候，可以进行拦截\neffect(() => {\n  app.innerHTML = flag.value;\n})\nlet flag1 : {\n  _value: false,\n  set() {},\n  get() {}\n}\n\nclass RefImpl {\n  __v_isRef = true;//增加ref标识\n  _value; //用来保存ref的值\n  constructor(public rawValue) {} //public会在实例上增加一个属性\n  set() {}\n  get() {}\n}\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);
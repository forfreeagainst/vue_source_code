(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{350:function(e,t,n){"use strict";n.r(t);var a=n(25),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"响应式系统reactivity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式系统reactivity"}},[e._v("#")]),e._v(" 响应式系统reactivity")]),e._v(" "),t("h2",{attrs:{id:"reactive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reactive"}},[e._v("#")]),e._v(" reactive")]),e._v(" "),t("h3",{attrs:{id:"使用proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用proxy"}},[e._v("#")]),e._v(" 使用proxy")]),e._v(" "),t("div",{staticClass:"language-reactive.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap,\n  )\n}\n\nfunction createReactiveObject(\n  target: Target,\n  isReadonly: boolean,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>,\n  proxyMap: WeakMap<Target, any>,\n) {\n  //....此处省略无数代码\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,\n  )\n  proxyMap.set(target, proxy)\n  return proxy\n}\n")])])]),t("h3",{attrs:{id:"使用reflect-重写proxy的proxyhandler中的set-get等其他方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用reflect-重写proxy的proxyhandler中的set-get等其他方法"}},[e._v("#")]),e._v(" 使用Reflect, 重写proxy的proxyHandler中的set/get等其他方法")]),e._v(" "),t("p",[e._v("为什么使用Reflect？\n不直接访问属性或改属性。receiver可以解决this指向问题。eg: Reflect.get(obj, fullname, receiver);")]),e._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[e._v("const obj = {\n    name: 'durant',\n    fullname() {\n        return 'kevin' + this.name;\n    }\n}\n")])])]),t("div",{staticClass:"language-baseHandlers.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export const mutableHandlers: ProxyHandler<object> =\n  /*#__PURE__*/ new MutableReactiveHandler()\n\n//重点寻找get的 track\n get(target: Target, key: string | symbol, receiver: object) {\n    // ...省略\n\n    const res = Reflect.get(target, key, receiver)\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n\n    // ...省略\n\n    return res\n  }\n\n//重点寻找set的 trigger\n  set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object,\n  ): boolean {\n    let oldValue = (target as any)[key]\n\n    // ...省略\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n\n")])])]),t("div",{staticClass:"language-collectionHandlers.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("collectionHandlers???\n")])])]),t("h3",{attrs:{id:"收集依赖-track"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#收集依赖-track"}},[e._v("#")]),e._v(" 收集依赖 track")]),e._v(" "),t("div",{staticClass:"language-reactiveEffect.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function track(target: object, type: TrackOpTypes, key: unknown) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep(() => depsMap!.delete(key))))\n    }\n    trackEffect(\n      activeEffect,\n      dep,\n      __DEV__\n        ? {\n            target,\n            type,\n            key,\n          }\n        : void 0,\n    )\n  }\n}\n")])])]),t("h3",{attrs:{id:"触发更新-trigger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发更新-trigger"}},[e._v("#")]),e._v(" 触发更新 trigger")]),e._v(" "),t("div",{staticClass:"language-reactiveEffect.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>,\n) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n\n  let deps: (Dep | undefined)[] = []\n  if (type === TriggerOpTypes.CLEAR) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()]\n  } else if (key === 'length' && isArray(target)) {\n    const newLength = Number(newValue)\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || (!isSymbol(key) && key >= newLength)) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  pauseScheduling()\n  for (const dep of deps) {\n    if (dep) {\n      triggerEffects(\n        dep,\n        DirtyLevels.Dirty,\n        __DEV__\n          ? {\n              target,\n              type,\n              key,\n              newValue,\n              oldValue,\n              oldTarget,\n            }\n          : void 0,\n      )\n    }\n  }\n  resetScheduling()\n}\n")])])]),t("h3",{attrs:{id:"收集依赖的effect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#收集依赖的effect"}},[e._v("#")]),e._v(" 收集依赖的effect")]),e._v(" "),t("div",{staticClass:"language-effect.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function trackEffect(\n  effect: ReactiveEffect,\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  if (dep.get(effect) !== effect._trackId) {\n    dep.set(effect, effect._trackId)\n    const oldDep = effect.deps[effect._depsLength]\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect)\n      }\n      effect.deps[effect._depsLength++] = dep\n    } else {\n      effect._depsLength++\n    }\n    if (__DEV__) {\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\n    }\n  }\n}\n")])])]),t("h3",{attrs:{id:"触发依赖的effect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发依赖的effect"}},[e._v("#")]),e._v(" 触发依赖的effect")]),e._v(" "),t("div",{staticClass:"language-effect.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function triggerEffects(\n  dep: Dep,\n  dirtyLevel: DirtyLevels,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  pauseScheduling()\n  for (const effect of dep.keys()) {\n    if (!effect.allowRecurse && effect._runnings) {\n      continue\n    }\n    if (\n      effect._dirtyLevel < dirtyLevel &&\n      (!effect._runnings || dirtyLevel !== DirtyLevels.ComputedValueDirty)\n    ) {\n      const lastDirtyLevel = effect._dirtyLevel\n      effect._dirtyLevel = dirtyLevel\n      if (\n        lastDirtyLevel === DirtyLevels.NotDirty &&\n        (!effect._queryings || dirtyLevel !== DirtyLevels.ComputedValueDirty)\n      ) {\n        if (__DEV__) {\n          effect.onTrigger?.(extend({ effect }, debuggerEventExtraInfo))\n        }\n        effect.trigger()\n        if (effect.scheduler) {\n          queueEffectSchedulers.push(effect.scheduler)\n        }\n      }\n    }\n  }\n  resetScheduling()\n}\n")])])]),t("h3",{attrs:{id:"最重要的effect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最重要的effect"}},[e._v("#")]),e._v(" ⭐️ 最重要的effect")]),e._v(" "),t("div",{staticClass:"language-effect.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function effect<T = any>(\n  fn: () => T,\n  options?: ReactiveEffectOptions,\n): ReactiveEffectRunner {\n  if ((fn as ReactiveEffectRunner).effect instanceof ReactiveEffect) {\n    fn = (fn as ReactiveEffectRunner).effect.fn\n  }\n\n  const _effect = new ReactiveEffect(fn, NOOP, () => {\n    if (_effect.dirty) {\n      _effect.run()\n    }\n  })\n  if (options) {\n    extend(_effect, options)\n    if (options.scope) recordEffectScope(_effect, options.scope)\n  }\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\n  runner.effect = _effect\n  return runner\n}\n")])])]),t("h2",{attrs:{id:"ref"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[e._v("#")]),e._v(" ref")]),e._v(" "),t("h3",{attrs:{id:"wrap-包了一层-因为对象在访问属性的时候-可以进行拦截"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#wrap-包了一层-因为对象在访问属性的时候-可以进行拦截"}},[e._v("#")]),e._v(" wrap,包了一层，因为对象在访问属性的时候，可以进行拦截")]),e._v(" "),t("div",{staticClass:"language-ref.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(\n    value: T,\n    public readonly __v_isShallow: boolean,\n  ) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\n    }\n  }\n}\n")])])]),t("h3",{attrs:{id:"ref收集依赖-trackrefvalue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref收集依赖-trackrefvalue"}},[e._v("#")]),e._v(" ref收集依赖 trackRefValue")]),e._v(" "),t("div",{staticClass:"language-ref.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    trackEffect(\n      activeEffect,\n      ref.dep ||\n        (ref.dep = createDep(\n          () => (ref.dep = undefined),\n          ref instanceof ComputedRefImpl ? ref : undefined,\n        )),\n      __DEV__\n        ? {\n            target: ref,\n            type: TrackOpTypes.GET,\n            key: 'value',\n          }\n        : void 0,\n    )\n  }\n}\n")])])]),t("h3",{attrs:{id:"ref触发更新-triggerrefvalue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref触发更新-triggerrefvalue"}},[e._v("#")]),e._v(" ref触发更新 triggerRefValue")]),e._v(" "),t("div",{staticClass:"language-ref.ts extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function triggerRefValue(\n  ref: RefBase<any>,\n  dirtyLevel: DirtyLevels = DirtyLevels.Dirty,\n  newVal?: any,\n) {\n  ref = toRaw(ref)\n  const dep = ref.dep\n  if (dep) {\n    triggerEffects(\n      dep,\n      dirtyLevel,\n      __DEV__\n        ? {\n            target: ref,\n            type: TriggerOpTypes.SET,\n            key: 'value',\n            newValue: newVal,\n          }\n        : void 0,\n    )\n  }\n}\n\n")])])]),t("h3",{attrs:{id:"剩下同reactive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#剩下同reactive"}},[e._v("#")]),e._v(" 剩下同reactive")])])}),[],!1,null,null,null);t.default=r.exports}}]);